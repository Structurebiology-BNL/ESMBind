import subprocess
import os
from constants import ion_charge


def execute_tleap_and_parmed(pdb_name, ion, temp_dir="./", verbose=False):
    """
    Execute tleap and parmed to prepare PDB file for simulation.

    Parameters:
    - pdb_name: The name of the PDB file without the extension.
    - ion: The type of ion to be used.

    Raises:
    - Exception: If the tleap or parmed command fails.
    """
    # Path for temporary tleap and parmed files
    tleap_input = os.path.join(temp_dir, "tleap.in")
    tleap_output = os.path.join(temp_dir, "tleap.out")
    parmed_input = os.path.join(temp_dir, "parmed.in")

    # Temporary output files generated by tleap and parmed
    prmtop_output = os.path.join(temp_dir, "amber.prmtop")
    inpcrd_output = os.path.join(temp_dir, "amber.inpcrd")

    tleap_commands = [
        "source leaprc.protein.ff19SB",
        "source leaprc.water.spce",
        "loadamberparams frcmod.ions234lm_1264_spce",  # "using frcmod.ions234lm_126_spce for 12-6 potential",
        f"mol = loadpdb {pdb_name}",
        "solvatebox mol SPCBOX 10.0",
        "loadamberparams frcmod.spce",
        f"savepdb mol {pdb_name}",
        f"saveamberparm mol {prmtop_output} {inpcrd_output}",
        "quit",
    ]

    tleap_script = "\n".join(tleap_commands)
    with open(tleap_input, "w") as file:
        file.write(tleap_script)

    try:
        if verbose:
            print(f"Running tleap for {pdb_name}...")
        subprocess.run(
            f"tleap -s -f {tleap_input} > {tleap_output}",
            shell=True,
            check=True,
            capture_output=True,
            text=True,
        )
    except Exception as e:  # This will catch CalledProcessError and other exceptions
        error_message = f"tleap command failed: {str(e)}"
        raise Exception(error_message) from e

    parmed_commands = [
        f"loadRestrt {inpcrd_output}",
        "setOverwrite True",
        f"add12_6_4 @{ion}{ion_charge[ion]} watermodel SPCE",
        f"outparm {prmtop_output} {inpcrd_output}",
    ]

    parmed_script = "\n".join(parmed_commands)
    with open(parmed_input, "w") as file:
        file.write(parmed_script)

    try:
        if verbose:
            print(f"Running parmed for {pdb_name}...")
        subprocess.run(
            f"parmed -i {parmed_input} -p {prmtop_output}",
            shell=True,
            check=True,
            capture_output=True,
            text=True,
        )
    except Exception as e:  # This will catch CalledProcessError and other exceptions
        error_message = f"parmed command failed: {str(e)}"
        raise Exception(error_message) from e

    if verbose:
        print("tleap and parmed executed successfully.")


def process_fasta_file(fasta_file):
    with open(fasta_file, "r") as file:
        lines = file.readlines()

    seq_dic, label_dic = {}, {}
    for i in range(0, len(lines), 3):
        id = lines[i].strip().replace(">", "")
        sequence = lines[i + 1].strip()
        seq_dic[id] = sequence
        label = list(map(int, list(lines[i + 2].strip())))
        label_dic[id] = label
        assert len(sequence) == len(label), "seq and label length mismatch"

    return seq_dic, label_dic


if __name__ == "__main__":
    execute_tleap_and_parmed("output.pdb", "MN", verbose=True)
